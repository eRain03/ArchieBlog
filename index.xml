<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>未淼</title><link>https://erain.fun/</link><description>Recent content on 未淼</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright> r3eck1ng</copyright><lastBuildDate>Sat, 17 May 2025 12:00:00 +0800</lastBuildDate><atom:link href="https://erain.fun/index.xml" rel="self" type="application/rss+xml"/><item><title>测试文章aaaaaaa - Hello Hugo</title><link>https://erain.fun/posts/2025/05/17/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0aaaaaaa-hello-hugo/</link><pubDate>Sat, 17 May 2025 12:00:00 +0800</pubDate><guid>https://erain.fun/posts/2025/05/17/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0aaaaaaa-hello-hugo/</guid><description>这是一个测试文章 这是用来测试你的 Hugo 博客自动构建和部署的文章。
时间戳：2025年5月18日 作者：你自己 目的：验证 GitHub Actions 自动触发构建 祝你测试成功！🚀</description></item><item><title>GRE Over IPSec 短记</title><link>https://erain.fun/posts/2024/07/07/gre-over-ipsec-%E7%9F%AD%E8%AE%B0/</link><pubDate>Sun, 07 Jul 2024 01:02:24 +0800</pubDate><guid>https://erain.fun/posts/2024/07/07/gre-over-ipsec-%E7%9F%AD%E8%AE%B0/</guid><description>要求FW1 与 RT2 之间用 Internet 互联地址建立 GRE Over IPSec VPN, 实现 Loopback4 之间的加密访问。RT2 的 ACL 名称为 ACL-VPN, transform-set 名称为 SET-1,crypto map 名称为 MAP-1。FW1 的 isakmp proposal 名称为 P-1,isakmp peer 名称为 PEER-1,ipsec proposal 名称为 P-2,tunnel ipsec 名称为 IPSEC-1,tunnel gre 名 称为 GRE-1。
网络拓扑如下
Internet交换机 200.200.200.1；200.200.200.5 RT2 连接Internet交换机 IP 地址为200.200.200.2 FW2 连接Internet交换机 自身IP为200.200.200.6 测试RT2是否能通过Internet Ping通 FW1 Ping 200.200.200.6 -i 200.200.200.2
RT2配置
interface Tunnel4 ip address 10.4.255.50 255.255.255.252 tunnel source 200.200.200.6 tunnel destination 200.</description></item><item><title>Hadoop集群配置</title><link>https://erain.fun/posts/2024/03/19/hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE/</link><pubDate>Tue, 19 Mar 2024 08:45:15 +0800</pubDate><guid>https://erain.fun/posts/2024/03/19/hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE/</guid><description>先前条件 Node1 Node2 Node3 192.168.1.39 192.168.1.9 192.168.1.40 关闭防火墙 停止防火墙进程 systemctl stop firewalld.service 禁用防火墙开机启动 systemctl disable firewalld.service 对三个节点分别修改主机名 hostnamectl set-hostname Node{1,2,3} 安装必要软件环境 yum install -y java-1.8.0-openjdk vim #安装jdk8和vim等必备软件 修改Hosts文件定向主机IP vim /etc/hosts node1 192.168.1.39 node2 192.168.1.9 node3 192.168.1.40 ping node1 ping node2 ping node3 测试连通性 给Node123添加hadoop用户并赋予sudo权限 Node123全部要做 [root@node2 ~]# useradd hadoop [root@node2 ~]# # 设置密码需要手动输入两次密码，笔者这里也暂时设定密码为hadoop [root@node2 ~]# passwd hadoop 更改用户 hadoop 的密码 。 新的 密码： 重新输入新的 密码： passwd：所有的身份验证令牌已经成功更新。 [root@node2 ~]# mkdir -p /data/hadoop [root@node2 ~]# chown hadoop:hadoop /data/hadoop chmod u+w /etc/sudoers vim /etc/sudoers # 在sudoers文件的root用户一行后面添加下面内容并且保存 hadoop ALL=(ALL) NOPASSWD:ALL chmod u-w /etc/sudoers sudo chmod -R a+w /data/hadoop 生成RSA密钥SSH免密登录 Node123全部要做 su hadoop ssh-keygen -t rsa ##按几次回车 cd /home/hadoop/.</description></item><item><title>《我，机器人》小记</title><link>https://erain.fun/posts/2024/01/22/%E6%88%91%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B0%8F%E8%AE%B0/</link><pubDate>Mon, 22 Jan 2024 21:58:34 +0800</pubDate><guid>https://erain.fun/posts/2024/01/22/%E6%88%91%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B0%8F%E8%AE%B0/</guid><description>第一法则 机器人不得伤害人类，或坐视人类受到伤害；
第二法则 机器人必须服从人类命令，除非命令与第一法则发生冲突；
第三法则 在不违背第一或第二法则之下，机器人可以保护自己。
这不是我第一次读这本书，开篇著名的艾氏机器人三定律首次登场 本书一共9个短篇，以回忆的方式叙述出来，所谓用“机器人心理学“去和异常的机器人打交道，如同书的标题“I,Robot” 书中的机器人三定律的第一法则的电平大于第二法则，第二法则的电平大于第三规则，机器人必须遵守这些“硬代码”否则会自毁
我很喜欢《Liar!》这篇（译文翻译的是“说假话的机器人”） 在生产机器人的的过程中出现了失误，使得机器人（代号：Herbie）拥有了类似读取脑电波的能力，赫比给研究机器人的专家们展现了它读取他们想法的能力，在谈话中赫比向人们透露了其他人的想法，使心理学家苏珊在感情问题上得到了她想知道的答案，赫比告诉了苏珊 米尔顿对她的爱恋之情，苏珊信以为真但在之后的聊天中米尔顿告诉苏珊自己要结婚了，苏珊这才意识到赫比欺骗了她，当众人人质问赫比为什么要撒谎时，赫比被逼的几乎疯癫说出了原因
“机器人不得伤害人类，或坐视人类受到伤害“
原来在赫比的逻辑中第一法则的电平依然是最大的，远超第二法则，赫比认为告诉他们真话会伤害到人类的感情，于是告诉了他们心中希望听到的答案 苏珊博士处于被欺骗和感情上的羞辱报复性地对赫比说 “你不能告诉他们，因为告诉他们，就是伤害他们，可如果你不告诉他们，你就是在伤害他们…” 赫比在心理学家苏珊的思想中感受到了无尽的苦痛，屈辱和仇恨，最终在苏珊创造的逻辑悖论下变成了一坨再也不能思考的废铁
机器人理解不了人类的感情，它只能按照第一法则去避免伤害到人类，没想到这种谎言最终使物理的伤害转变为了精神上的痛苦
这很有意思，不禁令人思考当下火爆的人工智能模型如何判断伤害到人类的范畴，人们也许会允许人在一些事情上犯错，但这种宽容会出现在人工智能上吗?</description></item><item><title>OSPF是如何计算出路由表来的？什么是SPF算法？</title><link>https://erain.fun/posts/2023/12/31/ospf%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%87%BA%E8%B7%AF%E7%94%B1%E8%A1%A8%E6%9D%A5%E7%9A%84%E4%BB%80%E4%B9%88%E6%98%AFspf%E7%AE%97%E6%B3%95/</link><pubDate>Sun, 31 Dec 2023 01:08:23 +0800</pubDate><guid>https://erain.fun/posts/2023/12/31/ospf%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%87%BA%E8%B7%AF%E7%94%B1%E8%A1%A8%E6%9D%A5%E7%9A%84%E4%BB%80%E4%B9%88%E6%98%AFspf%E7%AE%97%E6%B3%95/</guid><description>OSPF是如何计算出路由表来的？什么是SPF算法？写下在查阅了各种文档和书籍后开始对OSPF的一些理解，做此纪录用于学习和分享。
OSPF的特性 [Wiki] Wiki百科中这样写到 开放式最短路径优先（英语：Open Shortest Path First，缩写为 OSPF）是广泛使用的一种路由协议，它属于链路状态路由协议，具有路由变化收敛速度快、无路由环路、支持变长子网掩码（VLSM）和汇总、层次区域划分等优点。
不难看出OSPF有很多难以拒绝的优点，收敛速度快，树状的拓扑时期不会出现环路问题，很容易划分区域，方便管理等，也许这就是为什么大多数企业都会选择OSPF的原因(对比RIP不要好用太多太多) 在上一篇文章中，我们讨论了OSPF是如何选举DR，如何建立链接以及如何交换LSA数据库的。如果你还没有看那篇文章，建议先读一读再继续。
今天主要来看OSPF是如何计算出最短路由的。
SPF算法如何计算出优先算短路径？ SPF算法中有一个很重要的点叫Cost(花费),中文翻译过来叫花费，听起来就像去超市买东西花费了很多钱一样，但它有所不同，它更像是你从家门口打车去到某一个地方花了多少钱。 在树状图中Cost的值代表了一个节点到另一个节点所花费的跃点(Cost)，其实就是你经过了几个路由(节点)。 为什么是树状图？
如果对STP生成树协议有所了解的话，我们就会知道树状图能有效避免环路的问题，如图，树状图不会有任何一个”三角形“出现，这样的结构能避免环路的问题。
回到正题，我们要知道一点每一台路由(节点)都会运行SPF算法来计算出最短路径来，就像图中这四个节点一样，R1会计算出如下信息 R1&amp;mdash;R2 Cost=1 但它会计算其他的路径吗，不会。因为SPF不计算间接连接的节点所的Cost值。这或许能解释为什么在配置ospf时我们只会配置相邻的网段而不会配置间接连接的网段。我将四个节点所计算出的信息一一列出 R1: R1&amp;mdash;R2 Cost=1 R2: R2&amp;mdash;R1 Cost=1 R2&amp;mdash;R3 Cost=1 R3: R3&amp;mdash;R2 Cost=1 R3&amp;mdash;R4 Cost=1 R4: R4&amp;mdash;R3 Cost=1
此时每个节点会将自己计算的信息打包和相邻的节点进行数据库交互，它们交换数据包，就有了完整的最短路径树，如下：
R1的路径表：
到达R2的最短路径：R1-&amp;gt;R2，链路成本(Cost)为1 到达R3的最短路径：R1-&amp;gt;R2-&amp;gt;R3，链路成本为2 到达R4的最短路径：R1-&amp;gt;R2-&amp;gt;R3-&amp;gt;R4，链路成本为3 R2的路径表：
到达R1的最短路径：R2-&amp;gt;R1，链路成本为1 到达R3的最短路径：R2-&amp;gt;R3，链路成本为1 到达R4的最短路径：R2-&amp;gt;R3-&amp;gt;R4，链路成本为2 R3的路径表：
到达R1的最短路径：R3-&amp;gt;R2-&amp;gt;R1，链路成本为2 到达R2的最短路径：R3-&amp;gt;R2，链路成本为1 到达R4的最短路径：R3-&amp;gt;R4，链路成本为1 R4的路径表：
到达R1的最短路径：R4-&amp;gt;R3-&amp;gt;R2-&amp;gt;R1，链路成本为3 到达R2的最短路径：R4-&amp;gt;R3-&amp;gt;R2，链路成本为2 到达R3的最短路径：R4-&amp;gt;R3，链路成本为1 最短路径树 完整的最短路径树就是如此生成出来的，有了最短路径树，就像有了一张绝对快速不拖沓的地图。 用这张地图来计算路由表，计算出类似的信息
目标网络：x.x.x.x/x （查找最短路径） 下一跳：y.y.y.y （选择最快的下一跳路由） 出接口：GigabitEthernet0/1 SPF（Shortest Path First，最短路径优先）算法，也称为Dijkstra算法，是OSPF用来计算最短路径的核心算法。总结下来一共四大步骤，下面是SPF算法的工作原理和步骤：
1. 初始步骤 每个OSPF路由器会创建一个链路状态数据库（LSDB），存储关于网络拓扑的所有信息。 路由器通过发送和接收链路状态广告（LSA）来更新其LSDB，确保所有路由器的LSDB保持一致。 2.</description></item><item><title>Syntax Higlighters</title><link>https://erain.fun/posts/2020/06/23/syntax-higlighters/</link><pubDate>Tue, 23 Jun 2020 00:00:00 +0000</pubDate><guid>https://erain.fun/posts/2020/06/23/syntax-higlighters/</guid><description>Python def sum(a,b): return a+b print(f&amp;#39;The Sum of 4 and 5 is {sum(4,5)}&amp;#39;) JavaScript const sum = (a,b)=&amp;gt;{ return a+b } console.log(sum(4,5)) Go package main import ( &amp;#34;fmt&amp;#34; ) func addition(a int, b int) int { return a + b } func main() { x := addition(4, 5) fmt.Println(x) }</description></item><item><title>About Me</title><link>https://erain.fun/about/</link><pubDate>Sun, 12 Apr 2020 00:00:00 +0000</pubDate><guid>https://erain.fun/about/</guid><description/></item><item><title>Telegram Bot for GitHub Actions</title><link>https://erain.fun/posts/2020/04/01/telegram-bot-for-github-actions/</link><pubDate>Wed, 01 Apr 2020 00:00:00 +0000</pubDate><guid>https://erain.fun/posts/2020/04/01/telegram-bot-for-github-actions/</guid><description>Telegram Telegram is a cloud-based mobile and desktop messaging app with a focus on security and speed. It is free to use and extensively hackable. It also has a good bot support system. The API is also easy to implement and has many wrappers for building bots with the API.
GitHub Actions GitHub Actions is a CI/CD runtime for your GitHub repository. You can run almost anything from scripts to docker containers.</description></item><item><title>横向移动 通过SSH连接使目标机及作为Socks5代理服务器</title><link>https://erain.fun/posts/2019/10/15/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8-%E9%80%9A%E8%BF%87ssh%E8%BF%9E%E6%8E%A5%E4%BD%BF%E7%9B%AE%E6%A0%87%E6%9C%BA%E5%8F%8A%E4%BD%9C%E4%B8%BAsocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/</link><pubDate>Tue, 15 Oct 2019 20:05:30 +0800</pubDate><guid>https://erain.fun/posts/2019/10/15/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8-%E9%80%9A%E8%BF%87ssh%E8%BF%9E%E6%8E%A5%E4%BD%BF%E7%9B%AE%E6%A0%87%E6%9C%BA%E5%8F%8A%E4%BD%9C%E4%B8%BAsocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid><description>直接说方法 ssh -D &amp;lt;本地端口号&amp;gt; -f -C -q -N &amp;lt;用户名&amp;gt;@&amp;lt;SSH服务器地址&amp;gt; -D &amp;lt;本地端口号&amp;gt;：指定一个端口号，会在本地创建一个Socks5端口用于转发，所有通过这个端口号的连接都将被转发到SSH建立连接后的服务器，并由服务器发送到目标地址
-C：启用压缩，通过使用压缩，减少数据传输量，提高传输速度
-q：使用安静模式，禁止SSH客户端在连接过程中输出任何警告或错误消息，只输出关键信息
-N：告诉SSH客户端不要执行任何远程命令，在此情况下，只会建立SSH连接并启用端口转发
很多情况下，我们想要借助一台处于内网又能出网的业务服务器来访问到内网部分，又不能直接在服务器上安装服务，可以用服务器自带ssh服务建立一个连接，打通你和内网的互通，很方便，记录一下</description></item></channel></rss>